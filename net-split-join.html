<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Network Split / Join Studio</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/remixicon@3.5.0/fonts/remixicon.css">
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.jsdelivr.net/npm/ipaddr.js@2.1.0/ipaddr.min.js"></script>
  <style>
    body { font-family: system-ui, -apple-system, sans-serif; background: #f5f5f5; }
    .panel { background: white; }
    .row-hover { background-color: rgb(249 250 251); }
  </style>
</head>
<body class="min-h-screen p-5 md:p-10 text-gray-900">
  <main class="max-w-6xl mx-auto space-y-5">
    <header class="panel rounded p-4 md:p-6 border border-gray-300 flex flex-col md:flex-row md:items-center md:justify-between gap-4">
      <div>
        <p class="text-xs uppercase text-gray-600">Net atelier</p>
        <h1 class="text-3xl md:text-4xl font-semibold">Subnet Split & Join Table</h1>
        <p class="text-gray-600 mt-2">One-row-per-block controls with divide/join like the classic calculator.</p>
      </div>
      <div class="flex items-center gap-3">
        <input id="baseCidr" value="10.0.0.0/16" class="rounded border border-gray-300 px-3 py-2" placeholder="192.168.0.0/16">
        <button id="resetBtn" class="px-4 py-2 rounded bg-blue-600 text-white hover:bg-blue-700"><i class="ri-refresh-line mr-1"></i>Reset</button>
      </div>
    </header>

    <section class="panel rounded p-4 border border-gray-300">
      <div class="overflow-auto">
        <table class="min-w-full text-sm">
          <thead class="text-xs uppercase text-gray-600">
            <tr id="thead-row">
              <th class="px-2 py-2 text-left">Notes</th>
              <th class="px-2 py-2 text-left">Subnet</th>
              <th class="px-2 py-2 text-left">Range</th>
              <th class="px-2 py-2 text-left">Useable</th>
              <th class="px-2 py-2 text-left">Hosts</th>
              <th class="px-2 py-2 text-left">Divide</th>
              <th class="px-2 py-2 text-left" id="join-header">Join</th>
            </tr>
          </thead>
          <tbody id="calcbody" class="divide-y divide-gray-200"></tbody>
        </table>
      </div>
    </section>

    <section class="panel rounded p-4 border border-gray-300">
      <h2 class="text-lg font-semibold mb-3">Summary</h2>
      <pre id="summary" class="bg-gray-50 p-4 rounded text-xs overflow-auto font-mono"></pre>
    </section>
  </main>

  <script>
    const nameSeeds = ['net','Beacon','Cobalt','Delta','Echo','Flare','Gemini','Harbor','Ion','Juno','Kepler','Lumen'];
    let subnets = [];

    function saveState() {
      localStorage.setItem('subnets', JSON.stringify(subnets));
    }

    function loadState() {
      const saved = localStorage.getItem('subnets');
      if (saved) {
        try {
          subnets = JSON.parse(saved);
          render();
          return true;
        } catch (e) {
          return false;
        }
      }
      return false;
    }

    function parseCidr(cidr) {
      const trimmed = cidr.trim();
      const parsed = ipaddr.parseCIDR(trimmed);
      if (parsed[0].kind() !== 'ipv4') throw new Error('Only IPv4 supported');
      return parsed;
    }

    function toInt(ip) {
      return ip.octets.reduce((acc, oct) => (acc << 8) + oct, 0) >>> 0;
    }

    function fromInt(int) {
      const octets = [24,16,8,0].map(shift => (int >>> shift) & 255);
      return ipaddr.fromByteArray(octets);
    }

    function networkSize(prefix) {
      return Math.pow(2, 32 - prefix);
    }

    function formatRange(start, prefix) {
      const size = networkSize(prefix);
      const first = fromInt(start);
      const last = fromInt(start + size - 1);
      return `${first.toString()} - ${last.toString()}`;
    }

    function usableRange(start, prefix) {
      const size = networkSize(prefix);
      if (size <= 2) return 'n/a';
      const first = fromInt(start + 1);
      const last = fromInt(start + size - 2);
      return `${first.toString()} - ${last.toString()}`;
    }

    function initBase(cidr) {
      const [ip, prefix] = parseCidr(cidr);
      const start = toInt(ip) & (~0 << (32 - prefix));
      subnets = [{ start, prefix, label: nameSeeds[0] }];
      render();
      saveState();
    }

    function divide(idx) {
      const target = subnets[idx];
      if (target.prefix >= 32) return;
      const size = networkSize(target.prefix);
      const halfSize = size / 2;
      const first = { start: target.start, prefix: target.prefix + 1, label: target.label + ' 1' };
      const second = { start: target.start + halfSize, prefix: target.prefix + 1, label: target.label + ' 2' };
      subnets.splice(idx, 1, first, second);
      render();
      saveState();
    }

    function findJoinGroups() {
      const groups = [];
      if (subnets.length <= 1) return groups;

      for (let i = 0; i < subnets.length; i++) {
        const start = subnets[i].start;

        for (let targetPrefix = 0; targetPrefix < 32; targetPrefix++) {
          const targetSize = networkSize(targetPrefix);

          if (start % targetSize !== 0) continue;

          let addr = start;
          let count = 0;

          for (let j = i; j < subnets.length; j++) {
            const sub = subnets[j];
            if (sub.start !== addr) break;

            const subSize = networkSize(sub.prefix);
            if (addr + subSize > start + targetSize) break;

            addr += subSize;
            count++;
          }

          if (addr === start + targetSize && count > 1) {
            groups.push({ startIdx: i, count, targetPrefix, targetStart: start });
          }
        }
      }

      groups.sort((a, b) => {
        if (a.startIdx !== b.startIdx) return a.startIdx - b.startIdx;
        return b.targetPrefix - a.targetPrefix;
      });

      return groups;
    }

    function joinGroup(startIdx, count, targetPrefix, targetStart) {
      const label = subnets[startIdx].label.replace(/ [0-9]+$/, '');
      subnets.splice(startIdx, count, { start: targetStart, prefix: targetPrefix, label });
      render();
      saveState();
    }

    function updateSummary() {
      let totalUsable = 0;
      let totalHosts = 0;
      const prefixDist = {};
      let maxSize = 0;
      let minSize = Infinity;
      let maxSizeCidr = '';
      let minSizeCidr = '';

      let summary = '# Allocated Subnets\n\n';
      subnets.forEach(s => {
        const cidr = `${fromInt(s.start).toString()}/${s.prefix}`;
        const range = formatRange(s.start, s.prefix);
        const hosts = networkSize(s.prefix);
        const usable = hosts > 2 ? hosts - 2 : 0;
        totalUsable += usable;
        totalHosts += hosts;
        const label = s.label || 'Unnamed';

        prefixDist[s.prefix] = (prefixDist[s.prefix] || 0) + 1;

        if (hosts > maxSize) {
          maxSize = hosts;
          maxSizeCidr = cidr;
        }
        if (hosts < minSize) {
          minSize = hosts;
          minSizeCidr = cidr;
        }

        summary += `- ${cidr}: ${label}\n`;
        summary += `  - Range: ${range}\n`;
        summary += `  - Hosts: ${hosts} (${usable} usable)\n\n`;
      });

      if (subnets.length > 0) {
        const firstSubnet = subnets[0];
        const lastSubnet = subnets[subnets.length - 1];
        const firstStart = firstSubnet.start;
        const lastEnd = lastSubnet.start + networkSize(lastSubnet.prefix);
        const totalAllocated = lastEnd - firstStart;
        const overhead = totalHosts - totalUsable;
        const utilization = totalAllocated > 0 ? ((totalUsable / totalAllocated) * 100).toFixed(2) : 0;

        let gaps = 0;
        let gapAddresses = 0;
        for (let i = 1; i < subnets.length; i++) {
          const prevEnd = subnets[i-1].start + networkSize(subnets[i-1].prefix);
          const gap = subnets[i].start - prevEnd;
          if (gap > 0) {
            gaps++;
            gapAddresses += gap;
          }
        }

        summary += `# Summary\n\n`;
        summary += `- Total allocated: ${totalAllocated} addresses\n`;
        summary += `- Total usable: ${totalUsable} addresses\n`;
        summary += `- Utilization: ${utilization}%\n`;
        summary += `- Overhead: ${overhead} addresses (network + broadcast)\n`;
        summary += `- Subnets: ${subnets.length}\n`;
        summary += `- Largest: ${maxSizeCidr} (${maxSize} hosts)\n`;
        summary += `- Smallest: ${minSizeCidr} (${minSize} hosts)\n`;

        if (gaps > 0) {
          summary += `- Gaps: ${gaps} gap(s), ${gapAddresses} unused addresses\n`;
        }

        summary += `\n# Prefix Distribution\n\n`;
        Object.keys(prefixDist).sort((a, b) => a - b).forEach(prefix => {
          const count = prefixDist[prefix];
          const hosts = networkSize(parseInt(prefix));
          summary += `- /${prefix}: ${count} subnet(s) Ã— ${hosts} hosts = ${count * hosts} total\n`;
        });
      }

      document.getElementById('summary').textContent = summary;
    }

    function render() {
      subnets.sort((a, b) => a.start - b.start);
      const groups = findJoinGroups();

      const allPrefixes = [...new Set(groups.map(g => g.targetPrefix))].sort((a, b) => b - a);

      const rowSpanTracker = {};
      const activeJoinCells = {};
      allPrefixes.forEach(prefix => {
        rowSpanTracker[prefix] = 0;
        activeJoinCells[prefix] = null;
      });

      const body = document.getElementById('calcbody');
      body.innerHTML = '';

      subnets.forEach((row, idx) => {
        const tr = document.createElement('tr');
        const rowClass = `row-${idx}`;
        tr.className = rowClass;

        const noteTd = document.createElement('td');
        noteTd.className = 'px-2 py-2';
        const input = document.createElement('input');
        input.value = row.label || '';
        input.className = 'w-full rounded border border-gray-300 text-sm px-2 py-1';
        input.oninput = (e) => { row.label = e.target.value; updateSummary(); saveState(); };
        noteTd.appendChild(input);

        const subnetTd = document.createElement('td');
        subnetTd.className = 'px-2 py-2 whitespace-nowrap font-semibold';
        subnetTd.textContent = `${fromInt(row.start).toString()}/${row.prefix}`;

        const rangeTd = document.createElement('td');
        rangeTd.className = 'px-2 py-2 whitespace-nowrap';
        rangeTd.textContent = formatRange(row.start, row.prefix);

        const usableTd = document.createElement('td');
        usableTd.className = 'px-2 py-2 whitespace-nowrap';
        usableTd.textContent = usableRange(row.start, row.prefix);

        const hostsTd = document.createElement('td');
        hostsTd.className = 'px-2 py-2';
        hostsTd.textContent = networkSize(row.prefix);

        const divideTd = document.createElement('td');
        divideTd.className = 'px-2 py-2';
        const divideBtn = document.createElement('button');
        divideBtn.className = 'text-blue-600 hover:underline';
        divideBtn.textContent = 'Divide';
        divideBtn.disabled = row.prefix >= 32;
        divideBtn.onclick = () => divide(idx);
        divideTd.appendChild(divideBtn);

        tr.append(noteTd, subnetTd, rangeTd, usableTd, hostsTd, divideTd);

        const rowGroups = groups.filter(g => g.startIdx === idx);
        const groupsByPrefix = {};
        rowGroups.forEach(g => { groupsByPrefix[g.targetPrefix] = g; });

        allPrefixes.forEach(prefix => {
          if (rowSpanTracker[prefix] > 0) {
            rowSpanTracker[prefix]--;
            if (activeJoinCells[prefix]) {
              activeJoinCells[prefix].classList.add(rowClass);
            }
          } else if (groupsByPrefix[prefix]) {
            const group = groupsByPrefix[prefix];
            const joinTd = document.createElement('td');
            joinTd.className = `px-2 py-2 border-l border-gray-300 text-center cursor-pointer ${rowClass}`;
            joinTd.rowSpan = group.count;
            joinTd.innerHTML = `<span class="text-blue-600 font-semibold">/${group.targetPrefix}</span>`;
            joinTd.onclick = () => joinGroup(group.startIdx, group.count, group.targetPrefix, group.targetStart);
            tr.appendChild(joinTd);
            rowSpanTracker[prefix] = group.count - 1;
            activeJoinCells[prefix] = joinTd;
          } else {
            const emptyTd = document.createElement('td');
            emptyTd.className = 'px-2 py-2';
            tr.appendChild(emptyTd);
            activeJoinCells[prefix] = null;
          }
        });

        tr.onmouseenter = () => {
          document.querySelectorAll(`.${rowClass}`).forEach(el => {
            el.classList.add('row-hover');
          });
        };
        tr.onmouseleave = () => {
          document.querySelectorAll(`.${rowClass}`).forEach(el => {
            el.classList.remove('row-hover');
          });
        };

        body.appendChild(tr);
      });

      updateSummary();
    }

    document.getElementById('resetBtn').addEventListener('click', () => {
      const cidr = document.getElementById('baseCidr').value;
      try { initBase(cidr); } catch (err) { alert(err.message); }
    });

    if (!loadState()) {
      initBase(document.getElementById('baseCidr').value);
    }
  </script>
</body>
</html>
